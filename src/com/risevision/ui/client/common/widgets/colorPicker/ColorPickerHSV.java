package com.risevision.ui.client.common.widgets.colorPicker;

/**
 * Copyright (c) 2007, AurorisNET.
 *
 * Everyone is permitted to copy and distribute verbatim copies of this license
 * document, but changing it is not allowed.
 *
 * Preamble
 *
 * This license establishes the terms under which a given free software Package
 * may be copied, modified, distributed, and/or redistributed. The intent is
 * that the Copyright Holder maintains some artistic control over the
 * development of that Package while still keeping the Package available as open
 * source and free software.
 *
 * You are always permitted to make arrangements wholly outside of this license
 * directly with the Copyright Holder of a given Package. If the terms of this
 * license do not permit the full use that you propose to make of the Package,
 * you should contact the Copyright Holder and seek a different licensing
 * arrangement.
 *
 * Definitions
 *
 * "Copyright Holder" means the individual(s) or organization(s) named in the
 * copyright notice for the entire Package.
 *
 * "Contributor" means any party that has contributed code or other material to
 * the Package, in accordance with the Copyright Holder's procedures.
 *
 * "You" and "your" means any person who would like to copy, distribute, or
 * modify the Package.
 *
 * "Package" means the collection of files distributed by the Copyright Holder,
 * and derivatives of that collection and/or of those files. A given Package may
 * consist of either the Standard Version, or a Modified Version.
 *
 * "Distribute" means providing a copy of the Package or making it accessible to
 * anyone else, or in the case of a company or organization, to others outside
 * of your company or organization.
 *
 * "Distributor Fee" means any fee that you charge for Distributing this Package
 * or providing support for this Package to another party. It does not mean
 * licensing fees.
 *
 * "Standard Version" refers to the Package if it has not been modified, or has
 * been modified only in ways explicitly requested by the Copyright Holder.
 *
 * "Modified Version" means the Package, if it has been changed, and such
 * changes were not explicitly requested by the Copyright Holder.
 *
 * "Original License" means this Artistic License as Distributed with the
 * Standard Version of the Package, in its current version or as it may be
 * modified by The Perl Foundation in the future.
 *
 * "Source" form means the source code, documentation source, and configuration
 * files for the Package.
 *
 * "Compiled" form means the compiled bytecode, object code, binary, or any
 * other form resulting from mechanical transformation or translation of the
 * Source form.
 *
 * Permission for Use and Modification Without Distribution
 *
 * (1) You are permitted to use the Standard Version and create and use Modified
 * Versions for any purpose without restriction, provided that you do not
 * Distribute the Modified Version.
 *
 * Permissions for Redistribution of the Standard Version
 *
 * (2) You may Distribute verbatim copies of the Source form of the Standard
 * Version of this Package in any medium without restriction, either gratis or
 * for a Distributor Fee, provided that you duplicate all of the original
 * copyright notices and associated disclaimers. At your discretion, such
 * verbatim copies may or may not include a Compiled form of the Package.
 *
 * (3) You may apply any bug fixes, portability changes, and other modifications
 * made available from the Copyright Holder. The resulting Package will still be
 * considered the Standard Version, and as such will be subject to the Original
 * License.
 *
 * Distribution of Modified Versions of the Package as Source
 *
 * (4) You may Distribute your Modified Version as Source (either gratis or for
 * a Distributor Fee, and with or without a Compiled form of the Modified
 * Version) provided that you clearly document how it differs from the Standard
 * Version, including, but not limited to, documenting any non-standard
 * features, executables, or modules, and provided that you do at least ONE of
 * the following:
 *
 *      (a) make the Modified Version available to the Copyright Holder of the
 *          Standard Version, under the Original License, so that the Copyright
 *          Holder may include your modifications in the Standard Version.
 *
 *      (b) ensure that installation of your Modified Version does not prevent
 *          the user installing or running the Standard Version. In addition,
 *          the Modified Version must bear a name that is different from the
 *          name of the Standard Version.
 *
 *      (c) allow anyone who receives a copy of the Modified Version to make the
 *          Source form of the Modified Version available to others under
 *
 *          (i) the Original License or
 *
 *          (ii) a license that permits the licensee to freely copy, modify and
 *              redistribute the Modified Version using the same licensing terms
 *              that apply to the copy that the licensee received, and requires
 *              that the Source form ofthe Modified Version, and of any works
 *              derived from it, be made freely available in that license fees
 *              are prohibited but Distributor Fees are allowed.
 *
 * Distribution of Compiled Forms of the Standard Version or Modified Versions
 * without the Source
 *
 * (5) You may Distribute Compiled forms of the Standard Version without the
 * Source, provided that you include complete instructions on how to get the
 * Source of the Standard Version. Such instructions must be valid at the time
 * of your distribution. If these instructions, at any time while you are
 * carrying out such distribution, become invalid, you must provide new
 * instructions on demand or cease further distribution. If you provide valid
 * instructions or cease distribution within thirty days after you become aware
 * that the instructions are invalid, then you do not forfeit any of your rights
 * under this license.
 *
 * (6) You may Distribute a Modified Version in Compiled form without the
 * Source, provided that you comply with Section 4 with respect to the Source of
 * the Modified Version.
 *
 * Aggregating or Linking the Package
 *
 * (7) You may aggregate the Package (either the Standard Version or Modified
 * Version) with other packages and Distribute the resulting aggregation
 * provided that you do not charge a licensing fee for the Package. Distributor
 * Fees are permitted, and licensing fees for other components in the
 * aggregation are permitted. The terms of this license apply to the use and
 * Distribution of the Standard or Modified Versions as included in the
 * aggregation.
 *
 * (8) You are permitted to link Modified and Standard Versions with other
 * works, to embed the Package in a larger work of your own, or to build
 * stand-alone binary or bytecode versions of applications that include the
 * Package, and Distribute the result without restriction, provided the result
 * does not expose a direct interface to the Package.
 *
 * Items That are Not Considered Part of a Modified Version
 *
 * (9) Works (including, but not limited to, modules and scripts) that merely
 * extend or make use of the Package, do not, by themselves, cause the Package
 * to be a Modified Version. In addition, such works are not considered parts of
 * the Package itself, and are not subject to the terms of this license.
 *
 * General Provisions
 *
 * (10) Any use, modification, and distribution of the Standard or Modified
 * Versions is governed by this Artistic License. By using, modifying or
 * distributing the Package, you accept this license. Do not use, modify, or
 * distribute the Package, if you do not accept this license.
 *
 * (11) If your Modified Version has been derived from a Modified Version made
 * by someone other than you, you are nevertheless required to ensure that your
 * Modified Version complies with the requirements of this license.
 *
 * (12) This license does not grant you the right to use any trademark, service
 * mark, tradename, or logo of the Copyright Holder.
 *
 * (13) This license includes the non-exclusive, worldwide, free-of-charge
 * patent license to make, have made, use, offer to sell, sell, import and
 * otherwise transfer the Package with respect to any patent claims licensable
 * by the Copyright Holder that are necessarily infringed by the Package. If you
 * institute patent litigation (including a cross-claim or counterclaim) against
 * any party alleging that the Package constitutes direct or contributory patent
 * infringement, then this Artistic License to you shall terminate on the date
 * that such litigation is filed.
 *
 * (14) Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER
 * AND CONTRIBUTORS "AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
 * NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL LAW.
 * UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING IN ANY WAY
 * OUT OF THE USE OF THE PACKAGE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

import com.google.gwt.event.dom.client.ChangeEvent;
import com.google.gwt.event.dom.client.ChangeHandler;
import com.google.gwt.event.dom.client.KeyCodes;
import com.google.gwt.event.dom.client.KeyPressEvent;
import com.google.gwt.event.dom.client.KeyPressHandler;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.FlexTable;
import com.google.gwt.user.client.ui.TextBox;
import com.google.gwt.user.client.ui.Widget;

public class ColorPickerHSV extends Composite implements ColorPickerInterface, KeyPressHandler, ChangeHandler
{
    // Elements
    private int hue, saturation, brightness;
    
    private SliderBar sliderHue, sliderSaturation, sliderBrightness;
    private TextBox tbHue, tbSaturation, tbBrightness;
    private ColorPickerPreview previewWidget = ColorPickerPreview.getInstance();

    public ColorPickerHSV() {
        hue = 0;
        saturation = 100;
        brightness = 100;

        FlexTable table = new FlexTable();

        // Add the small slider bar
        sliderHue = new SliderBar(this, false, SliderBar.Hue);
        sliderSaturation = new SliderBar(this, false, SliderBar.Saturation);
        sliderBrightness = new SliderBar(this, false, SliderBar.Brightness);

        // Textboxes
        tbHue = new TextBox();
        tbHue.setText(new Integer(hue).toString());
        tbHue.setMaxLength(3);
        tbHue.setVisibleLength(4);
        tbHue.addKeyPressHandler(this);
        tbHue.addChangeHandler(this);
        tbSaturation = new TextBox();
        tbSaturation.setText(new Integer(saturation).toString());
        tbSaturation.setMaxLength(3);
        tbSaturation.setVisibleLength(4);
        tbSaturation.addKeyPressHandler(this);
        tbSaturation.addChangeHandler(this);
        tbBrightness = new TextBox();
        tbBrightness.setText(new Integer(brightness).toString());
        tbBrightness.setMaxLength(3);
        tbBrightness.setVisibleLength(4);
        tbBrightness.addKeyPressHandler(this);
        tbBrightness.addChangeHandler(this);

        // Define the Flextable's content
        table.setText(0, 0, "Hue:");
        table.setWidget(1, 0, sliderHue);
        table.setWidget(1, 1, tbHue);
        table.setText(2, 0, "Saturation:");
        table.setWidget(3, 0, sliderSaturation);
        table.setWidget(3, 1, tbSaturation);
        table.setText(4, 0, "Brightness:");
        table.setWidget(5, 0, sliderBrightness);
        table.setWidget(5, 1, tbBrightness);

        styleControls();
        
        // Final setup
        initWidget(table);
    }
    
    private void styleControls() {
    	tbHue.setStyleName("rdn-TextBoxShort");
    	tbSaturation.setStyleName("rdn-TextBoxShort");
    	tbBrightness.setStyleName("rdn-TextBoxShort");
    }

    /**
     * This method is called when a widget is attached to the browser's document. To receive notification after a Widget has been added to the document, override the Widget.onLoad() method.
     *
     * Subclasses that override this method must call <tt>super.onAttach()</tt> before doing anything else to ensure that the Widget has been properly attached to its underlying Element.
     */
    @Override
    protected void onAttach() {
        // Called when we are shown (from being hidden)
        super.onAttach();
        updateSliders();
    }

    /**
     * Fires whenever the user generates picking events along the color picker bar.
     *
     * Subclasses that override this method must call <tt>super.onBarSelected(y)</tt> to ensure that the Widget recieves its events.
     * @param y the distance along the y-axis of the user's selection, between 0 and 255, inclusive.
     */
    public void onBarSelected(int colorMode, int y) {
        switch (colorMode)
        {
            case SliderBar.Hue:
                hue = percentOf(y, 360);
                tbHue.setText(Integer.toString(hue));
                onChange(tbHue);
                break;
            case SliderBar.Saturation:
                saturation = percentOf(y, 100);
                tbSaturation.setText(Integer.toString(saturation));
                onChange(tbSaturation);
                break;
            case SliderBar.Brightness:
                brightness = percentOf(y, 100);
                tbBrightness.setText(Integer.toString(brightness));
                onChange(tbBrightness);
                break;
        }
    }
    
    public void onMapSelected(int x, int y) {
    }

    /*
     * (non-Javadoc)
     * @see com.google.gwt.event.dom.client.ChangeHandler#onChange(com.google.gwt.event.dom.client.ChangeEvent)
     */
    public void onChange(ChangeEvent event) {
        onChange((Widget)event.getSource());
    }

    /**
     * Fired whenever something in this widget changes.
     *
     * Subclasses that override this method must call <tt>super.onChange(sender)</tt> to ensure that the Widget recieves its events.
     * @param sender the widget that has changed.
     */
    private void onChange(Widget sender) {
        if (sender == tbHue || sender == tbSaturation || sender == tbBrightness)
        {
            // Don't allow this value to overflow
            try
            {
                if (Integer.parseInt(tbHue.getText()) > 359)
                {
                    tbHue.setText("359");
                }

                if (Integer.parseInt(tbSaturation.getText()) > 100)
                {
                    tbSaturation.setText("100");
                }

                if (Integer.parseInt(tbBrightness.getText()) > 100)
                {
                    tbBrightness.setText("100");
                }
            }
            catch (Exception e)
            {
            }

            hue = Integer.parseInt(tbHue.getText());
            saturation = Integer.parseInt(tbSaturation.getText());
            brightness = Integer.parseInt(tbBrightness.getText());

            updatePreview();
        }

        // Let the sliders know something's changed
        updateSliders();
    }
    
    private void updatePreview() {
        // Figure out colors
        try
        {
            Color color = new Color();
            color.setHSV(hue, saturation, brightness);
            previewWidget.setPreview(color.getHex());
        }
        catch (Exception e)
        {
        }
    }

    /**
     * Called whenever the internal state has been changed and needs to synchronize the other components.
     */
    private void updateSliders() {
        sliderHue.setSliderPosition(256 - (int)((new Integer(hue).floatValue() / 360) * 256));

        try
        {
            Color color = new Color();
            color.setHSV(hue, 100, brightness);
            sliderSaturation.setLayerColor("#" + color.getHex(), SliderBar.BarD);
        }
        catch (Exception e) {}

        sliderSaturation.setSliderPosition(256 - (int)((new Integer(saturation).floatValue() / 100) * 256));

        try
        {
            Color color = new Color();
            color.setHSV(hue, saturation, 100);
            sliderBrightness.setLayerColor("#" + color.getHex(), SliderBar.BarD);
        }
        catch (Exception e) {}

        sliderBrightness.setSliderPosition(256 - (int)((new Integer(brightness).floatValue() / 100) * 256));

    }

    /**
     * Fired when a keyboard action generates a character. This occurs after onKeyDown and onKeyUp are fired for the physical key that was pressed.
     *
     * It should be noted that many browsers do not generate keypress events for non-printing keyCode values, such as KEY_ENTER or arrow keys. These keyCodes can be reliably captured either with onKeyDown(Widget, char, int) or onKeyUp(Widget, char, int).
     *
     * Subclasses that override this method must call <tt>super.onKeyPress(sender, keyCode, modifiers)</tt> to ensure that the Widget recieves its events.
     * @param sender the widget that was focused when the event occurred.
     * @see com.google.gwt.user.client.ui.KeyboardListener
     */
    public void onKeyPress(KeyPressEvent event) {
        Widget sender = (Widget) event.getSource();
        char keyCode = event.getCharCode();

        // Disallow non-numerics in numeric boxes
        if ((!Character.isDigit(keyCode))
            && (keyCode != (char) KeyCodes.KEY_TAB)
            && (keyCode != (char) KeyCodes.KEY_BACKSPACE)
            && (keyCode != (char) KeyCodes.KEY_DELETE) && (keyCode != (char) KeyCodes.KEY_ENTER)
            && (keyCode != (char) KeyCodes.KEY_HOME) && (keyCode != (char) KeyCodes.KEY_END)
            && (keyCode != (char) KeyCodes.KEY_LEFT) && (keyCode != (char) KeyCodes.KEY_UP)
            && (keyCode != (char) KeyCodes.KEY_RIGHT) && (keyCode != (char) KeyCodes.KEY_DOWN))
        {
            ((TextBox)sender).cancelKey();
        }
    }

    /*Helper functions -- for common calculations
     */
    /**
     * Divides the first value by 256, then multiplies it by the second value.
     * @param val1 first value.
     * @param val2 second value.
     * @return result.
     */
    private int percentOf(int val1, int val2) {
        return (int)(new Float(val1).floatValue() / 256 * val2);
    }

    public void setColor(Color color) {
        this.hue = color.getHue();
        this.saturation = color.getSaturation();
        this.brightness = color.getValue();

        tbHue.setText(Integer.toString(this.hue));
        tbSaturation.setText(Integer.toString(this.saturation));
        tbBrightness.setText(Integer.toString(this.brightness));

        updateSliders();
    }

}